// Big O Notation
//Классическое понятие -
//Асимптотическая сложность алгоритма -
//O(n) , где n - размер входных данных

//Иными словами - способ описать, как будет расти время 
//выполнения алгоритма в зависимости от роста входных данных

//=============================================
//Константная сложность O(1) (Constant Time)
//Время выполнения не зависит от размера входных данных
function getFirstElement(arr) {
    return arr[3];
}

console.log(getFirstElement([1, 2, 3, 4, 5])); // 1
const array2 = new Array(1000000).fill("test");
console.log(getFirstElement(array2)); // "test"

//=============================================

//Линейная сложность O(n) (Linear Time)
//Время выполнения растет линейно с ростом входных данных
//если 'n' удваивается, время выполнения тоже удваивается
console.log("---O(n) Линейная сложность---");

//Пример - найти сумму всех чисел в массиве
//чтобы найти сумму, нужно пройтись по КАЖДОМУ элементу массива
function sumArray(arr) {
    let sum = 0;
    for (let i = 0; i < arr.length; i++) { //arr.length это наше 'n'
        sum += arr[i]; //Цикл выполняется n раз
    }
    return sum;
}
console.log(sumArray([1, 2, 3, 4, 5])); // 15
const array1 = new Array(1000000).fill(1);
console.log(sumArray(array1)); // 1000000

//O(n^2) - Квадратичная сложность (Quadratic Time)
//Время выполнения растет квадратично с ростом входных данных
//если 'n' удваивается, время выполнения увеличивается в 4 раза
console.log("---O(n^2) Квадратичная сложность---");

//Пример - найти все дубликаты в массиве
function hasDuplicates(arr) {
    const n = arr.length;   
    for (let i = 0; i < n; i++) {          //Внешний цикл выполняется n раз
        for (let j = i + 1; j < n; j++) {  //Внутренний цикл тоже выполняется n раз
            if (i !== j && arr[i] === arr[j]) {
                return true; // Найден дубликат
            }
        }
    }
    return false; // Дубликаты не найдены
}    
console.log(hasDuplicates([1, 2, 3, 4, 5])); // false
console.log(hasDuplicates([1, 2, 3, 4, 5, 3])); // true

//=============================================
//Логарифмическая сложность O(log n) (Logarithmic Time)
//Время выполнения растет логарифмически с ростом входных данных
//если 'n' удваивается, время выполнения увеличивается на 1
console.log("---O(log n) Логарифмическая сложность---");

/**
 * Пример - бинарный поиск в отсортированном массиве
 * 
 * Бинарный поиск работает по принципу "разделяй и властвуй"
 * Он делит массив пополам и определяет, в какой половине 
 * может находиться искомый элемент, затем повторяет процесс для этой половины.
 */

function binarySearch(sortedArray, target) {
    let left = 0;
    let right = sortedArray.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (sortedArray[mid] === target) {
            return mid; // Элемент найден
        }
        if (sortedArray[mid] < target) {
            left = mid + 1; // Искомый элемент в правой половине
        } else {
            right = mid - 1; // Искомый элемент в левой половине
        }
    }
    return -1; // Элемент не найден
} //количество итераций будет логарифмическим от размера массива   


const sortedNumbers = [2, 5, 8, 12, 16, 23, 56, 72, 88, 110];
console.log(binarySearch(sortedNumbers, 23)); 
console.log(binarySearch(sortedNumbers, 99));

//=============================================
//Линейно-логарифмическая сложность O(n log n) (Linearithmic Time)
//Время выполнения растет как n log n с ростом входных данных
//"Золотая середина" между O(n) и O(n^2)
//Большинство эффективных алгоритмов сортировки имеют такую сложность
console.log("---O(n log n) Линейно-логарифмическая сложность---");

//Пример. Сортировка массива.
//Используем встроенный метод sort, который обычно реализован в большинстве движков JS

function sortArray(arr) {
    //Мы здесь не пишем свой алгоритм сортировки,
    //а используем встроенный метод, 
    return arr.slice().sort((a, b) => a - b); //slice() чтобы не мутировать исходный массив
}

const unsortedArray = [5, 3, 8, 1, 2, 7];
console.log("Сортировка исходного массива", sortArray(unsortedArray)); 

//=============================================
//Экспоненциальная сложность O(2^n) (Exponential Time)
//Время выполнения удваивается с каждым добавлением элемента к входным данным

console.log("---O(2^n) Экспоненциальная сложность---");

//Пример - рекурсивное вычисление чисел Фибоначчи
function fibonacci(n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2); //Два рекурсивных вызова
}

console.log(fibonacci(5)); // 5
console.log(fibonacci(40)); // 102334155

//=============================================
//Факториальная сложность O(n!) (Factorial Time)
//Время выполнения растет факториально с ростом входных данных
//Ужасно неэффективно для больших n
console.log("---O(n!) Факториальная сложность---");

//Пример - генерация всех перестановок массива

function findPermutations(arr) {
    if (arr.length === 0) {
        return;
    }
    for (let i = 0; i < arr.length; i++) {
        const rest = arr.slice(0, i).concat(arr.slice(i + 1));
        findPermutations(rest);
    }
}    

console.log("Поиск перестановок массива [1,2,3] (n=3, n! = 6 перестановок)");
findPermutations([1, 2, 3]); //6 перестановок
//findPermutations([1, 2, 3, 4, 5, 6, 7]); //5040 перестановок - браузер зависает

