// Файл для объяснения основных понятий объектно-ориентированного программирования (ООП) в JavaScript

// ООП - это парадигма программирования, основанная на представлении программы в виде совокупности объектов,
// каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

// -----------------------------------------------------------------
// 1. Класс и Объект (Class & Object)
// -----------------------------------------------------------------
// Класс — это "чертеж" для создания объектов. Он описывает свойства (данные) и методы (поведение), 
// которыми будут обладать все объекты, созданные на его основе.

// Объект — это конкретный экземпляр класса, с собственным состоянием свойств.

console.log("--- 1. Классы и Объекты ---");

class Animal {
    // `constructor` - специальный метод для создания и инициализации объекта.
    // Он вызывается автоматически при создании нового экземпляра класса (через `new`).
    constructor(name, age) {
        // `this` ссылается на создаваемый экземпляр объекта.
        // Свойства объекта:
        this.name = name;
        this.age = age;
    }

    // Метод - это функция, принадлежащая классу. Он описывает поведение объекта.
    speak() {
        // Обратите внимание, что разные животные будут издавать разные звуки.
        // Это пример полиморфизма, который мы рассмотрим подробнее ниже.
        console.log(`${this.name} издает какой-то звук.`);
    }

    // Еще один метод для вывода информации
    displayInfo() {
        console.log(`Имя: ${this.name}, Возраст: ${this.age}`);
    }
}

// Создание объектов (экземпляров) класса Animal
const genericAnimal = new Animal("Животное", 3);
const myDog = new Animal("Рекс", 5);

genericAnimal.displayInfo(); // Вывод: Имя: Животное, Возраст: 3
myDog.displayInfo();         // Вывод: Имя: Рекс, Возраст: 5
myDog.speak();               // Вывод: Рекс издает какой-то звук.


// -----------------------------------------------------------------
// 2. Инкапсуляция (Encapsulation)
// -----------------------------------------------------------------
// Инкапсуляция — это объединение данных (свойств) и методов для работы с этими данными в одном компоненте (классе).
// А также сокрытие внутренней реализации от внешнего мира.
// В JS для создания "приватных" полей и методов используется префикс `#`.

console.log("\n--- 2. Инкапсуляция ---");

class BankAccount {
    #balance = 0; // Приватное свойство. Доступно только внутри класса BankAccount.

    constructor(initialBalance) {
        if (initialBalance > 0) {
            this.#balance = initialBalance;
        }
    }

    // Публичный метод для внесения денег (интерфейс для взаимодействия)
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
            console.log(`Счет пополнен на ${amount}. Текущий баланс: ${this.#getBalance()}`);
        }
    }

    // Публичный метод для снятия денег
    withdraw(amount) {
        if (amount > 0 && amount <= this.#balance) {
            this.#balance -= amount;
            console.log(`Со счета снято ${amount}. Текущий баланс: ${this.#getBalance()}`);
        } else {
            console.log("Недостаточно средств или некорректная сумма.");
        }
    }

    // Приватный метод. Может быть вызван только другими методами этого же класса.
    #getBalance() {
        return this.#balance;
    }
}

const myAccount = new BankAccount(100);
myAccount.deposit(50);    // OK
myAccount.withdraw(30);   // OK
// console.log(myAccount.#balance); // -> Ошибка! Нельзя получить доступ к приватному полю снаружи.
// myAccount.#getBalance();         // -> Ошибка! Нельзя вызвать приватный метод снаружи.


// -----------------------------------------------------------------
// 3. Наследование (Inheritance)
// -----------------------------------------------------------------
// Наследование — механизм, который позволяет создавать новый класс (потомок) 
// на основе существующего (родитель), заимствуя его свойства и методы.

console.log("\n--- 3. Наследование ---");

// Класс Dog (потомок) наследуется от класса Animal (родитель)
class Dog extends Animal {
    constructor(name, age, breed) {
        // `super()` вызывает конструктор родительского класса (Animal).
        // Это нужно сделать перед использованием `this`.
        super(name, age);
        this.breed = breed; // Добавляем новое свойство, специфичное для собаки
    }

    // Переопределение (Override) родительского метода `speak`
    speak() {
        console.log(`${this.name} лает: Гав-гав!`);
    }

    // Можно вызывать и родительский метод внутри дочернего
    displayInfo() {
        super.displayInfo(); // Вызываем displayInfo() из класса Animal
        console.log(`Порода: ${this.breed}`);
    }
}

const anotherDog = new Dog("Шарик", 2, "Овчарка");
anotherDog.displayInfo(); // Вызовет оба метода: родительский и дочерний
anotherDog.speak();       // Вызовет переопределенный метод


// -----------------------------------------------------------------
// 4. Полиморфизм (Polymorphism)
// -----------------------------------------------------------------
// Полиморфизм (буквально "много форм") — это способность объектов с одинаковым интерфейсом 
// (названиями методов) иметь разную реализацию этих методов.

console.log("\n--- 4. Полиморфизм ---");

class Cat extends Animal {
    // Переопределяем метод speak для кошки
    speak() {
        console.log(`${this.name} мяукает: Мяу!`);
    }
}

const dogForPolymorphism = new Dog("Бобик", 4, "Такса");
const catForPolymorphism = new Cat("Мурка", 1);

// Создаем массив из разных объектов, которые имеют общий интерфейс (метод speak)
const animals = [dogForPolymorphism, catForPolymorphism, new Animal("Нечто", 1)];

// Проходим по массиву и вызываем один и тот же метод `speak()` для каждого объекта.
// В зависимости от класса объекта будет вызвана своя реализация этого метода.
animals.forEach(animal => {
    animal.speak();
});
// Вывод:
// Бобик лает: Гав-гав!
// Мурка мяукает: Мяу!
// Нечто издает какой-то звук.
